A preliminary version of this paper appears in the proceedings of the 23rd ACM Conference on Computer and Communications Security
(CCS 2016). This is a full version.
Deep Learning with Differential Privacy
October 25, 2016
Martín Abadi∗ Andy Chu∗ Ian Goodfellow†
H. Brendan McMahan∗ Ilya Mironov∗ Kunal Talwar∗
Li Zhang∗
ABSTRACT
Machine learning techniques based on neural networks are
achieving remarkable results in a wide variety of domains.
Often, the training of models requires large, representative
datasets, which may be crowdsourced and contain sensitive
information. The models should not expose private informa-
tion in these datasets. Addressing this goal, we develop new
algorithmic techniques for learning and a refined analysis of
privacy costs within the framework of differential privacy.
Our implementation and experiments demonstrate that we
can train deep neural networks with non-convex objectives,
under a modest privacy budget, and at a manageable cost in
software complexity, training efficiency, and model quality.
1. INTRODUCTION
Recent progress in neural networks has led to impressive
successes in a wide range of applications, including image
classification, language representation, move selection for
Go, and many more (e.g., [54, 28, 56, 38, 51]). These ad-
vances are enabled, in part, by the availability of large and
representative datasets for training neural networks. These
datasets are often crowdsourced, and may contain sensitive
information. Their use requires techniques that meet the
demands of the applications while offering principled and
rigorous privacy guarantees.
In this paper, we combine state-of-the-art machine learn-
ing methods with advanced privacy-preserving mechanisms,
training neural networks within a modest (“single-digit”) pri-
vacy budget. We treat models with non-convex objectives,
several layers, and tens of thousands to millions of param-
eters. (In contrast, previous work obtains strong results on
convex models with smaller numbers of parameters, or treats
complex neural networks but with a large privacy loss.) For
this purpose, we develop new algorithmic techniques, a re-
fined analysis of privacy costs within the framework of dif-
ferential privacy, and careful implementation strategies:
∗Google.
†OpenAI. Work done while at Google.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS’16 October 24-28, 2016, Vienna, Austria
c© 2016 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-4139-4/16/10.
DOI: http://dx.doi.org/10.1145/2976749.2978318
1. We demonstrate that, by tracking detailed information
(higher moments) of the privacy loss, we can obtain
much tighter estimates on the overall privacy loss, both
asymptotically and empirically.
2. We improve the computational efficiency of differen-
tially private training by introducing new techniques.
These techniques include efficient algorithms for com-
puting gradients for individual training examples, sub-
dividing tasks into smaller batches to reduce memory
footprint, and applying differentially private principal
projection at the input layer.
3. We build on the machine learning framework Tensor-
Flow [3] for training models with differential privacy.
We evaluate our approach on two standard image clas-
sification tasks, MNIST and CIFAR-10. We chose
these two tasks because they are based on public data-
sets and have a long record of serving as benchmarks
in machine learning. Our experience indicates that
privacy protection for deep neural networks can be
achieved at a modest cost in software complexity, train-
ing efficiency, and model quality.
Machine learning systems often comprise elements that
contribute to protecting their training data. In particular,
regularization techniques, which aim to avoid overfitting to
the examples used for training, may hide details of those
examples. On the other hand, explaining the internal rep-
resentations in deep neural networks is notoriously difficult,
and their large capacity entails that these representations
may potentially encode fine details of at least some of the
training data. In some cases, a determined adversary may
be able to extract parts of the training data. For example,
Fredrikson et al. demonstrated a model-inversion attack that
recovers images from a facial recognition system [24].
While the model-inversion attack requires only “black-
box” access to a trained model (that is, interaction with the
model via inputs and outputs), we consider adversaries with
additional capabilities, much like Shokri and Shmatikov [50].
Our approach offers protection against a strong adversary
with full knowledge of the training mechanism and access
to the model’s parameters. This protection is attractive,
in particular, for applications of machine learning on mobile
phones, tablets, and other devices. Storing models on-device
enables power-efficient, low-latency inference, and may con-
tribute to privacy since inference does not require commu-
nicating user data to a central server; on the other hand,
we must assume that the model parameters themselves may
be exposed to hostile inspection. Furthermore, when we are
arXiv:1607.00133v2 [stat.ML] 24 Oct 2016
concerned with preserving the privacy of one record in the
training data, we allow for the possibility that the adversary
controls some or even all of the rest of the training data. In
practice, this possibility cannot always be excluded, for ex-
ample when the data is crowdsourced.
The next section reviews background on deep learning and
on differential privacy. Sections 3 and 4 explain our ap-
proach and implementation. Section 5 describes our exper-
imental results. Section 6 discusses related work, and Sec-
tion 7 concludes. Deferred proofs appear in the Appendix.
2. BACKGROUND
In this section we briefly recall the definition of differential
privacy, introduce the Gaussian mechanism and composition
theorems, and overview basic principles of deep learning.
2.1 Differential Privacy
Differential privacy [19, 16, 20] constitutes a strong stan-
dard for privacy guarantees for algorithms on aggregate data-
bases. It is defined in terms of the application-specific con-
cept of adjacent databases. In our experiments, for instance,
each training dataset is a set of image-label pairs; we say
that two of these sets are adjacent if they differ in a single
entry, that is, if one image-label pair is present in one set
and absent in the other.
Definition 1. A randomized mechanism M : D → R with
domain D and range R satisfies (ε, δ)-differential privacy if
for any two adjacent inputs d, d′ ∈ D and for any subset of
outputs S ⊆ R it holds that
Pr[M(d) ∈ S] ≤ eε Pr[M(d′) ∈ S] + δ.
The original definition of ε-differential privacy does not in-
clude the additive term δ. We use the variant introduced by
Dwork et al. [17], which allows for the possibility that plain
ε-differential privacy is broken with probability δ (which is
preferably smaller than 1/|d|).
Differential privacy has several properties that make it
particularly useful in applications such as ours: composabil-
ity, group privacy, and robustness to auxiliary information.
Composability enables modular design of mechanisms: if all
the components of a mechanism are differentially private,
then so is their composition. Group privacy implies graceful
degradation of privacy guarantees if datasets contain cor-
related inputs, such as the ones contributed by the same
individual. Robustness to auxiliary information means that
privacy guarantees are not affected by any side information
available to the adversary.
A common paradigm for approximating a deterministic
real-valued function f : D → R with a differentially private
mechanism is via additive noise calibrated to f ’s sensitivity
Sf , which is defined as the maximum of the absolute distance
|f (d) − f (d′)| where d and d′ are adjacent inputs. (The
restriction to a real-valued function is intended to simplify
this review, but is not essential.) For instance, the Gaussian
noise mechanism is defined by
M(d) ∆
= f (d) + N (0, S2
f · σ2),
where N (0, S2
f · σ2) is the normal (Gaussian) distribution
with mean 0 and standard deviation Sf σ. A single applica-
tion of the Gaussian mechanism to function f of sensitivity
Sf satisfies (ε, δ)-differential privacy if δ ≥ 4
5 exp(−(σε)2/2)
and ε < 1 [20, Theorem 3.22]. Note that this analysis of
the mechanism can be applied post hoc, and, in particular,
that there are infinitely many (ε, δ) pairs that satisfy this
condition.
Differential privacy for repeated applications of additive-
noise mechanisms follows from the basic composition theo-
rem [17, 18], or from advanced composition theorems and
their refinements [22, 32, 21, 10]. The task of keeping track
of the accumulated privacy loss in the course of execution
of a composite mechanism, and enforcing the applicable pri-
vacy policy, can be performed by the privacy accountant,
introduced by McSherry [40].
The basic blueprint for designing a differentially private
additive-noise mechanism that implements a given function-
ality consists of the following steps: approximating the func-
tionality by a sequential composition of bounded-sensitivity
functions; choosing parameters of additive noise; and per-
forming privacy analysis of the resulting mechanism. We
follow this approach in Section 3.
2.2 Deep Learning
Deep neural networks, which are remarkably effective for
many machine learning tasks, define parameterized func-
tions from inputs to outputs as compositions of many layers
of basic building blocks, such as affine transformations and
simple nonlinear functions. Commonly used examples of the
latter are sigmoids and rectified linear units (ReLUs). By
varying parameters of these blocks, we can “train” such a pa-
rameterized function with the goal of fitting any given finite
set of input/output examples.
More precisely, we define a loss function L that represents
the penalty for mismatching the training data. The loss L(θ)
on parameters θ is the average of the loss over the training
examples {x1, . . . , xN }, so L(θ) = 1
N
∑
i L(θ, xi). Training
consists in finding θ that yields an acceptably small loss,
hopefully the smallest loss (though in practice we seldom
expect to reach an exact global minimum).
For complex networks, the loss function L is usually non-
convex and difficult to minimize. In practice, the minimiza-
tion is often done by the mini-batch stochastic gradient de-
scent (SGD) algorithm. In this algorithm, at each step,
one forms a batch B of random examples and computes
gB = 1/|B| ∑
x∈B ∇θ L(θ, x) as an estimation to the gra-
dient ∇θ L(θ). Then θ is updated following the gradient
direction −gB towards a local minimum.
Several systems have been built to support the definition
of neural networks, to enable efficient training, and then
to perform efficient inference (execution for fixed parame-
ters) [29, 12, 3]. We base our work on TensorFlow, an open-
source dataflow engine released by Google [3]. TensorFlow
allows the programmer to define large computation graphs
from basic operators, and to distribute their execution across
a heterogeneous distributed system. TensorFlow automates
the creation of the computation graphs for gradients; it also
makes it easy to batch computation.
3. OUR APPROACH
This section describes the main components of our ap-
proach toward differentially private training of neural net-
works: a differentially private stochastic gradient descent
(SGD) algorithm, the moments accountant, and hyperpa-
rameter tuning.
3.1 Differentially Private SGD Algorithm
One might attempt to protect the privacy of training data
by working only on the final parameters that result from the
training process, treating this process as a black box. Un-
fortunately, in general, one may not have a useful, tight
characterization of the dependence of these parameters on
the training data; adding overly conservative noise to the pa-
rameters, where the noise is selected according to the worst-
case analysis, would destroy the utility of the learned model.
Therefore, we prefer a more sophisticated approach in which
we aim to control the influence of the training data during
the training process, specifically in the SGD computation.
This approach has been followed in previous works (e.g., [52,
7]); we make several modifications and extensions, in par-
ticular in our privacy accounting.
Algorithm 1 outlines our basic method for training a model
with parameters θ by minimizing the empirical loss function
L(θ). At each step of the SGD, we compute the gradient
∇θ L(θ, xi) for a random subset of examples, clip the `2 norm
of each gradient, compute the average, add noise in order to
protect privacy, and take a step in the opposite direction of
this average noisy gradient. At the end, in addition to out-
putting the model, we will also need to compute the privacy
loss of the mechanism based on the information maintained
by the privacy accountant. Next we describe in more detail
each component of this algorithm and our refinements.
Algorithm 1 Differentially private SGD (Outline)
Input: Examples {x1, . . . , xN }, loss function L(θ) =
1
N
∑
i L(θ, xi). Parameters: learning rate ηt, noise scale
σ, group size L, gradient norm bound C.
Initialize θ0 randomly
for t ∈ [T ] do
Take a random sample Lt with sampling probability
L/N
Compute gradient
For each i ∈ Lt, compute gt(xi) ← ∇θt L(θt, xi)
Clip gradient
¯gt(xi) ← gt(xi)/ max (1, ‖gt(xi)‖2
C
)
Add noise
˜gt ← 1
L
(∑
i ¯gt(xi) + N (0, σ2C2I))
Descent
θt+1 ← θt − ηt ˜gt
Output θT and compute the overall privacy cost (ε, δ)
using a privacy accounting method.
Norm clipping: Proving the differential privacy guarantee
of Algorithm 1 requires bounding the influence of each indi-
vidual example on ˜gt. Since there is no a priori bound on
the size of the gradients, we clip each gradient in `2 norm;
i.e., the gradient vector g is replaced by g/ max (1, ‖g‖2
C
),
for a clipping threshold C. This clipping ensures that if
‖g‖2 ≤ C, then g is preserved, whereas if ‖g‖2 > C, it gets
scaled down to be of norm C. We remark that gradient clip-
ping of this form is a popular ingredient of SGD for deep
networks for non-privacy reasons, though in that setting it
usually suffices to clip after averaging.
Per-layer and time-dependent parameters: The pseu-
docode for Algorithm 1 groups all the parameters into a
single input θ of the loss function L(·). For multi-layer neu-
ral networks, we consider each layer separately, which allows
setting different clipping thresholds C and noise scales σ for
different layers. Additionally, the clipping and noise param-
eters may vary with the number of training steps t. In results
presented in Section 5 we use constant settings for C and σ.
Lots: Like the ordinary SGD algorithm, Algorithm 1 esti-
mates the gradient of L by computing the gradient of the
loss on a group of examples and taking the average. This av-
erage provides an unbiased estimator, the variance of which
decreases quickly with the size of the group. We call such a
group a lot, to distinguish it from the computational group-
ing that is commonly called a batch. In order to limit mem-
ory consumption, we may set the batch size much smaller
than the lot size L, which is a parameter of the algorithm.
We perform the computation in batches, then group several
batches into a lot for adding noise. In practice, for efficiency,
the construction of batches and lots is done by randomly per-
muting the examples and then partitioning them into groups
of the appropriate sizes. For ease of analysis, however, we as-
sume that each lot is formed by independently picking each
example with probability q = L/N , where N is the size of
the input dataset.
As is common in the literature, we normalize the running
time of a training algorithm by expressing it as the number
of epochs, where each epoch is the (expected) number of
batches required to process N examples. In our notation,
an epoch consists of N/L lots.
Privacy accounting: For differentially private SGD, an
important issue is computing the overall privacy cost of the
training. The composability of differential privacy allows
us to implement an “accountant” procedure that computes
the privacy cost at each access to the training data, and
accumulates this cost as the training progresses. Each step
of training typically requires gradients at multiple layers,
and the accountant accumulates the cost that corresponds
to all of them.
Moments accountant: Much research has been devoted
to studying the privacy loss for a particular noise distribu-
tion as well as the composition of privacy losses. For the
Gaussian noise that we use, if we choose σ in Algorithm 1
to be
√
2 log 1.25
δ /ε, then by standard arguments [20] each
step is (ε, δ)-differentially private with respect to the lot.
Since the lot itself is a random sample from the database,
the privacy amplification theorem [33, 8] implies that each
step is (O(qε), qδ)-differentially private with respect to the
full database where q = L/N is the sampling ratio per lot
and ε ≤ 1. The result in the literature that yields the best
overall bound is the strong composition theorem [22].
However, the strong composition theorem can be loose,
and does not take into account the particular noise distribu-
tion under consideration. In our work, we invent a stronger
accounting method, which we call the moments accountant.
It allows us to prove that Algorithm 1 is (O(qε√T ), δ)-
differentially private for appropriately chosen settings of the
noise scale and the clipping threshold. Compared to what
one would obtain by the strong composition theorem, our
bound is tighter in two ways: it saves a √log(1/δ) factor in
the ε part and a T q factor in the δ part. Since we expect
δ to be small and T  1/q (i.e., each example is examined
multiple times), the saving provided by our bound is quite
significant. This result is one of our main contributions.
Theorem 1. There exist constants c1 and c2 so that given
the sampling probability q = L/N and the number of steps
T , for any ε < c1q2T , Algorithm 1 is (ε, δ)-differentially
private for any δ > 0 if we choose
σ ≥ c2
q√T log(1/δ)
ε .
If we use the strong composition theorem, we will then
need to choose σ = Ω(q√T log(1/δ) log(T /δ)/ε). Note that
we save a factor of √log(T /δ) in our asymptotic bound. The
moments accountant is beneficial in theory, as this result
indicates, and also in practice, as can be seen from Figure 2
in Section 4. For example, with L = 0.01N , σ = 4, δ =
10−5, and T = 10000, we have ε ≈ 1.26 using the moments
accountant. As a comparison, we would get a much larger
ε ≈ 9.34 using the strong composition theorem.
3.2 The Moments Accountant: Details
The moments accountant keeps track of a bound on the
moments of the privacy loss random variable (defined be-
low in Eq. (1)). It generalizes the standard approach of
tracking (ε, δ) and using the strong composition theorem.
While such an improvement was known previously for com-
posing Gaussian mechanisms, we show that it applies also
for composing Gaussian mechanisms with random sampling
and can provide much tighter estimate of the privacy loss of
Algorithm 1.
Privacy loss is a random variable dependent on the ran-
dom noise added to the algorithm. That a mechanism M
is (ε, δ)-differentially private is equivalent to a certain tail
bound on M’s privacy loss random variable. While the tail
bound is very useful information on a distribution, compos-
ing directly from it can result in quite loose bounds. We in-
stead compute the log moments of the privacy loss random
variable, which compose linearly. We then use the moments
bound, together with the standard Markov inequality, to ob-
tain the tail bound, that is the privacy loss in the sense of
differential privacy.
More specifically, for neighboring databases d, d′ ∈ Dn, a
mechanism M, auxiliary input aux, and an outcome o ∈ R,
define the privacy loss at o as
c(o; M, aux, d, d′) ∆
= log Pr[M(aux, d) = o]
Pr[M(aux, d′) = o] . (1)
A common design pattern, which we use extensively in the
paper, is to update the state by sequentially applying differ-
entially private mechanisms. This is an instance of adaptive
composition, which we model by letting the auxiliary input
of the kth mechanism Mk be the output of all the previous
mechanisms.
For a given mechanism M, we define the λth moment
αM(λ; aux, d, d′) as the log of the moment generating func-
tion evaluated at the value λ:
αM(λ; aux, d, d′) ∆
=
log Eo∼M(aux,d)[exp(λc(o; M, aux, d, d′))]. (2)
In order to prove privacy guarantees of a mechanism, it is
useful to bound all possible αM(λ; aux, d, d′). We define
αM(λ) ∆
= max
aux,d,d′ αM(λ; aux, d, d′) ,
where the maximum is taken over all possible aux and all
the neighboring databases d, d′.
We state the properties of α that we use for the moments
accountant.
Theorem 2. Let αM(λ) defined as above. Then
1. [Composability] Suppose that a mechanism M con-
sists of a sequence of adaptive mechanisms M1, . . . , Mk
where Mi : ∏i−1
j=1 Rj × D → Ri. Then, for any λ
αM(λ) ≤
k∑
i=1
αMi (λ) .
2. [Tail bound] For any ε > 0, the mechanism M is
(ε, δ)-differentially private for
δ = min
λ exp(αM(λ) − λε) .
In particular, Theorem 2.1 holds when the mechanisms
themselves are chosen based on the (public) output of the
previous mechanisms.
By Theorem 2, it suffices to compute, or bound, αMi (λ) at
each step and sum them to bound the moments of the mech-
anism overall. We can then use the tail bound to convert the
moments bound to the (ε, δ)-differential privacy guarantee.
The main challenge that remains is to bound the value
αMt (λ) for each step. In the case of a Gaussian mechanism
with random sampling, it suffices to estimate the following
moments. Let μ0 denote the probability density function
(pdf) of N (0, σ2), and μ1 denote the pdf of N (1, σ2). Let μ
be the mixture of two Gaussians μ = (1 − q)μ0 + qμ1. Then
we need to compute α(λ) = log max(E1, E2) where
E1 = Ez∼μ0 [(μ0(z)/μ(z))λ] , (3)
E2 = Ez∼μ [(μ(z)/μ0(z))λ] . (4)
In the implementation of the moments accountant, we
carry out numerical integration to compute α(λ). In ad-
dition, we can show the asymptotic bound
α(λ) ≤ q2λ(λ + 1)/(1 − q)σ2 + O(q3/σ3) .
Together with Theorem 2, the above bound implies our
main Theorem 1. The details can be found in the Appendix.
3.3 Hyperparameter Tuning
We identify characteristics of models relevant for privacy
and, specifically, hyperparameters that we can tune in order
to balance privacy, accuracy, and performance. In particu-
lar, through experiments, we observe that model accuracy
is more sensitive to training parameters such as batch size
and noise level than to the structure of a neural network.
If we try several settings for the hyperparameters, we can
trivially add up the privacy costs of all the settings, possibly
via the moments accountant. However, since we care only
about the setting that gives us the most accurate model, we
can do better, such as applying a version of a result from
Gupta et al. [27] restated as Theorem D.1 in the Appendix.
We can use insights from theory to reduce the number of
hyperparameter settings that need to be tried. While differ-
entially private optimization of convex objective functions
is best achieved using batch sizes as small as 1, non-convex
learning, which is inherently less stable, benefits from ag-
gregation into larger batches. At the same time, Theorem 1
suggests that making batches too large increases the pri-
vacy cost, and a reasonable tradeoff is to take the number
of batches per epoch to be of the same order as the desired
number of epochs. The learning rate in non-private train-
ing is commonly adjusted downwards carefully as the model
converges to a local optimum. In contrast, we never need
to decrease the learning rate to a very small value, because
differentially private training never reaches a regime where
it would be justified. On the other hand, in our experi-
ments, we do find that there is a small benefit to starting
with a relatively large learning rate, then linearly decaying
it to a smaller value in a few epochs, and keeping it constant
afterwards.
4. IMPLEMENTATION
We have implemented the differentially private SGD al-
gorithms in TensorFlow. The source code is available under
an Apache 2.0 license from github.com/tensorflow/models.
For privacy protection, we need to “sanitize” the gradient
before using it to update the parameters. In addition, we
need to keep track of the “privacy spending” based on how
the sanitization is done. Hence our implementation mainly
consists of two components: sanitizer, which preprocesses
the gradient to protect privacy, and privacy_accountant,
which keeps track of the privacy spending over the course of
training.
Figure 1 contains the TensorFlow code snippet (in Python)
of DPSGD_Optimizer, which minimizes a loss function us-
ing a differentially private SGD, and DPTrain, which itera-
tively invokes DPSGD_Optimizer using a privacy accountant
to bound the total privacy loss.
In many cases, the neural network model may benefit from
the processing of the input by projecting it on the principal
directions (PCA) or by feeding it through a convolutional
layer. We implement differentially private PCA and apply
pre-trained convolutional layers (learned on public data).
Sanitizer. In order to achieve privacy protection, the sani-
tizer needs to perform two operations: (1) limit the sensitiv-
ity of each individual example by clipping the norm of the
gradient for each example; and (2) add noise to the gradient
of a batch before updating the network parameters.
In TensorFlow, the gradient computation is batched for
performance reasons, yielding gB = 1/|B| ∑
x∈B ∇θ L(θ, x)
for a batch B of training examples. To limit the sensitivity
of updates, we need to access each individual ∇θ L(θ, x). To
this end, we implemented per_example_gradient operator
in TensorFlow, as described by Goodfellow [25]. This opera-
tor can compute a batch of individual ∇θ L(θ, x). With this
implementation there is only a modest slowdown in train-
ing, even for larger batch size. Our current implementation
supports batched computation for the loss function L, where
each xi is singly connected to L, allowing us to handle most
hidden layers but not, for example, convolutional layers.
Once we have the access to the per-example gradient, it
is easy to use TensorFlow operators to clip its norm and to
add noise.
Privacy accountant. The main component in our imple-
mentation is PrivacyAccountant which keeps track of pri-
vacy spending over the course of training. As discussed in
Section 3, we implemented the moments accountant that ad-
ditively accumulates the log of the moments of the privacy
loss at each step. Dependent on the noise distribution, one
can compute α(λ) by either applying an asymptotic bound,
evaluating a closed-form expression, or applying numerical
class DPSGD_Optimizer():
def __init__(self, accountant, sanitizer):
self._accountant = accountant
self._sanitizer = sanitizer
def Minimize(self, loss, params,
batch_size, noise_options):
# Accumulate privacy spending before computing
# and using the gradients.
priv_accum_op =
self._accountant.AccumulatePrivacySpending(
batch_size, noise_options)
with tf.control_dependencies(priv_accum_op):
# Compute per example gradients
px_grads = per_example_gradients(loss, params)
# Sanitize gradients
sanitized_grads = self._sanitizer.Sanitize(
px_grads, noise_options)
# Take a gradient descent step
return apply_gradients(params, sanitized_grads)
def DPTrain(loss, params, batch_size, noise_options):
accountant = PrivacyAccountant()
sanitizer = Sanitizer()
dp_opt = DPSGD_Optimizer(accountant, sanitizer)
sgd_op = dp_opt.Minimize(
loss, params, batch_size, noise_options)
eps, delta = (0, 0)
# Carry out the training as long as the privacy
# is within the pre-set limit.
while within_limit(eps, delta):
sgd_op.run()
eps, delta = accountant.GetSpentPrivacy()
Figure 1: Code snippet of DPSGD_Optimizer and DP-
Train.
integration. The first option would recover the generic ad-
vanced composition theorem, and the latter two give a more
accurate accounting of the privacy loss.
For the Gaussian mechanism we use, α(λ) is defined ac-
cording to Eqs. (3) and (4). In our implementation, we
carry out numerical integration to compute both E1 and E2
in those equations. Also we compute α(λ) for a range of
λ’s so we can compute the best possible (ε, δ) values using
Theorem 2.2. We find that for the parameters of interest to
us, it suffices to compute α(λ) for λ ≤ 32.
At any point during training, one can query the privacy
loss in the more interpretable notion of (ε, δ) privacy using
Theorem 2.2. Rogers et al. [47] point out risks associated
with adaptive choice of privacy parameters. We avoid their
attacks and negative results by fixing the number of iter-
ations and privacy parameters ahead of time. More gen-
eral implementations of a privacy accountant must correctly
distinguish between two modes of operation—as a privacy
odometer or a privacy filter (see [47] for more details).
Differentially private PCA. Principal component analy-
sis (PCA) is a useful method for capturing the main features
of the input data. We implement the differentially private
PCA algorithm as described in [23]. More specifically, we
take a random sample of the training examples, treat them
as vectors, and normalize each vector to unit `2 norm to
form the matrix A, where each vector is a row in the ma-
trix. We then add Gaussian noise to the covariance matrix
AT A and compute the principal directions of the noisy co-
variance matrix. Then for each input example we apply the
projection to these principal directions before feeding it into
the neural network.
We incur a privacy cost due to running a PCA. However,
we find it useful for both improving the model quality and for
reducing the training time, as suggested by our experiments
on the MNIST data. See Section 4 for details.
Convolutional layers. Convolutional layers are useful for
deep neural networks. However, an efficient per-example
gradient computation for convolutional layers remains a chal-
lenge within the TensorFlow framework, which motivates
creating a separate workflow. For example, some recent
work argues that even random convolutions often suffice [46,
13, 49, 55, 14].
Alternatively, we explore the idea of learning convolu-
tional layers on public data, following Jarrett et al. [30].
Such convolutional layers can be based on GoogLeNet or
AlexNet features [54, 35] for image models or on pretrained
word2vec or GloVe embeddings in language models [41, 44].
5. EXPERIMENTAL RESULTS
This section reports on our evaluation of the moments ac-
countant, and results on two popular image datasets: MNIST
and CIFAR-10.
5.1 Applying the Moments Accountant
As shown by Theorem 1, the moments accountant pro-
vides a tighter bound on the privacy loss compared to the
generic strong composition theorem. Here we compare them
using some concrete values. The overall privacy loss (ε, δ)
can be computed from the noise level σ, the sampling ra-
tio of each lot q = L/N (so each epoch consists of 1/q
batches), and the number of epochs E (so the number of
steps is T = E/q). We fix the target δ = 10−5, the value
used for our MNIST and CIFAR experiments.
In our experiment, we set q = 0.01, σ = 4, and δ = 10−5,
and compute the value of ε as a function of the training
epoch E. Figure 2 shows two curves corresponding to, re-
spectively, using the strong composition theorem and the
moments accountant. We can see that we get a much tighter
estimation of the privacy loss by using the moments accoun-
tant. For examples, when E = 100, the values are 9.34
and 1.26 respectively, and for E = 400, the values are 24.22
and 2.55 respectively. That is, using the moments bound,
we achieve (2.55, 10−5)-differential privacy, whereas previ-
ous techniques only obtain the significantly worse guarantee
of (24.22, 10−5).
5.2 MNIST
We conduct experiments on the standard MNIST dataset
for handwritten digit recognition consisting of 60,000 train-
ing examples and 10,000 testing examples [36]. Each exam-
ple is a 28 × 28 size gray-level image. We use a simple feed-
forward neural network with ReLU units and softmax of 10
classes (corresponding to the 10 digits) with cross-entropy
loss and an optional PCA input layer.
Baseline model.
Our baseline model uses a 60-dimensional PCA projection
layer and a single hidden layer with 1,000 hidden units. Us-
ing the lot size of 600, we can reach accuracy of 98.30% in
about 100 epochs. This result is consistent with what can
be achieved with a vanilla neural network [36].
Figure 2: The ε value as a function of epoch E for
q = 0.01, σ = 4, δ = 10−5, using the strong composition
theorem and the moments accountant respectively.
Differentially private model.
For the differentially private version, we experiment with
the same architecture with a 60-dimensional PCA projection
layer, a single 1,000-unit ReLU hidden layer, and a lot size of
600. To limit sensitivity, we clip the gradient norm of each
layer at 4. We report results for three choices of the noise
scale, which we call small (σ = 2, σp = 4), medium (σ =
4, σp = 7), and large (σ = 8, σp = 16). Here σ represents
the noise level for training the neural network, and σp the
noise level for PCA projection. The learning rate is set at 0.1
initially and linearly decreased to 0.052 over 10 epochs and
then fixed to 0.052 thereafter. We have also experimented
with multi-hidden-layer networks. For MNIST, we found
that one hidden layer combined with PCA works better than
a two-layer network.
Figure 3 shows the results for different noise levels. In
each plot, we show the evolution of the training and testing
accuracy as a function of the number of epochs as well as
the corresponding δ value, keeping ε fixed. We achieve 90%,
95%, and 97% test set accuracy for (0.5, 10−5), (2, 10−5),
and (8, 10−5)-differential privacy respectively.
One attractive consequence of applying differentially pri-
vate SGD is the small difference between the model’s ac-
curacy on the training and the test sets, which is consis-
tent with the theoretical argument that differentially private
training generalizes well [6]. In contrast, the gap between
training and testing accuracy in non-private training, i.e.,
evidence of overfitting, increases with the number of epochs.
By using the moments accountant, we can obtain a δ value
for any given ε. We record the accuracy for different (ε, δ)
pairs in Figure 4. In the figure, each curve corresponds to the
best accuracy achieved for a fixed δ, as it varies between 10−5
and 10−2. For example, we can achieve 90% accuracy for
ε = 0.25 and δ = 0.01. As can be observed from the figure,
for a fixed δ, varying the value of ε can have large impact
on accuracy, but for any fixed ε, there is less difference with
different δ values.
Effect of the parameters.
Classification accuracy is determined by multiple factors
(1) Large noise (2) Medium noise (3) Small noise
Figure 3: Results on the accuracy for different noise levels on the MNIST dataset. In all the experiments, the
network uses 60 dimension PCA projection, 1,000 hidden units, and is trained using lot size 600 and clipping
threshold 4. The noise levels (σ, σp) for training the neural network and for PCA projection are set at (8, 16),
(4, 7), and (2, 4), respectively, for the three experiments.
Figure 4: Accuracy of various (ε, δ) privacy values
on the MNIST dataset. Each curve corresponds to
a different δ value.
that must be carefully tuned for optimal performance. These
factors include the topology of the network, the number of
PCA dimensions and the number of hidden units, as well as
parameters of the training procedure such as the lot size and
the learning rate. Some parameters are specific to privacy,
such as the gradient norm clipping bound and the noise level.
To demonstrate the effects of these parameters, we manip-
ulate them individually, keeping the rest constant. We set
the reference values as follows: 60 PCA dimensions, 1,000
hidden units, 600 lot size, gradient norm bound of 4, ini-
tial learning rate of 0.1 decreasing to a final learning rate
of 0.052 in 10 epochs, and noise σ equal to 4 and 7 respec-
tively for training the neural network parameters and for the
PCA projection. For each combination of values, we train
until the point at which (2, 10−5)-differential privacy would
be violated (so, for example, a larger σ allows more epochs
of training). The results are presented in Figure 5.
PCA projection. In our experiments, the accuracy is
fairly stable as a function of the PCA dimension, with the
best results achieved for 60. (Not doing PCA reduces ac-
curacy by about 2%.) Although in principle the PCA pro-
jection layer can be replaced by an additional hidden layer,
we achieve better accuracy by training the PCA layer sep-
arately. By reducing the input size from 784 to 60, PCA
leads to an almost 10× reduction in training time. The re-
sult is fairly stable over a large range of the noise levels for
the PCA projection and consistently better than the accu-
racy using random projection, which is at about 92.5% and
shown as a horizontal line in the plot.
Number of hidden units. Including more hidden units
makes it easier to fit the training set. For non-private train-
ing, it is often preferable to use more units, as long as we
employ techniques to avoid overfitting. However, for differ-
entially private training, it is not a priori clear if more hidden
units improve accuracy, as more hidden units increase the
sensitivity of the gradient, which leads to more noise added
at each update.
Somewhat counterintuitively, increasing the number of
hidden units does not decrease accuracy of the trained model.
One possible explanation that calls for further analysis is
that larger networks are more tolerant to noise. This prop-
erty is quite encouraging as it is common in practice to use
very large networks.
Lot size. According to Theorem 1, we can run N/L epochs
while staying within a constant privacy budget. Choosing
the lot size must balance two conflicting objectives. On the
one hand, smaller lots allow running more epochs, i.e., passes
over data, improving accuracy. On the other hand, for a
larger lot, the added noise has a smaller relative effect.
Our experiments show that the lot size has a relatively
large impact on accuracy. Empirically, the best lot size is
roughly √N where N is the number of training examples.
Learning rate. Accuracy is stable for a learning rate in
the range of [0.01, 0.07] and peaks at 0.05, as shown in Fig-
ure 5(4). However, accuracy decreases significantly if the
learning rate is too large. Some additional experiments sug-
gest that, even for large learning rates, we can reach similar
levels of accuracy by reducing the noise level and, accord-
ingly, by training less in order to avoid exhausting the pri-
vacy budget.
Clipping bound. Limiting the gradient norm has two op-
posing effects: clipping destroys the unbiasedness of the gra-
dient estimate, and if the clipping parameter is too small,
the average clipped gradient may point in a very different
(1) variable projection dimensions (2) variable hidden units (3) variable lot size
(4) variable learning rate (5) variable gradient clipping norm (6) variable noise level
Figure 5: MNIST accuracy when one parameter varies, and the others are fixed at reference values.
direction from the true gradient. On the other hand, in-
creasing the norm bound C forces us to add more noise to
the gradients (and hence the parameters), since we add noise
based on σC. In practice, a good way to choose a value for
C is by taking the median of the norms of the unclipped
gradients over the course of training.
Noise level. By adding more noise, the per-step privacy
loss is proportionally smaller, so we can run more epochs
within a given cumulative privacy budget. In Figure 5(5),
the x-axis is the noise level σ. The choice of this value has
a large impact on accuracy.
From the experiments, we observe the following.
1. The PCA projection improves both model accuracy
and training performance. Accuracy is quite stable
over a large range of choices for the projection dimen-
sions and the noise level used in the PCA stage.
2. The accuracy is fairly stable over the network size.
When we can only run smaller number of epochs, it is
more beneficial to use a larger network.
3. The training parameters, especially the lot size and
the noise scale σ, have a large impact on the model
accuracy. They both determine the “noise-to-signal”
ratio of the sanitized gradients as well as the number
of epochs we are able to go through the data before
reaching the privacy limit.
Our framework allows for adaptive control of the training
parameters, such as the lot size, the gradient norm bound
C, and noise level σ. Our initial experiments with decreas-
ing noise as training progresses did not show a significant
improvement, but it is interesting to consider more sophis-
ticated schemes for adaptively choosing these parameters.
5.3 CIFAR
We also conduct experiments on the CIFAR-10 dataset,
which consists of color images classified into 10 classes such
as ships, cats, and dogs, and partitioned into 50,000 training
examples and 10,000 test examples [1]. Each example is a
32 × 32 image with three channels (RGB). For this learning
task, nearly all successful networks use convolutional layers.
The CIFAR-100 dataset has similar parameters, except that
images are classified into 100 classes; the examples and the
image classes are different from those of CIFAR-10.
We use the network architecture from the TensorFlow con-
volutional neural networks tutorial [2]. Each 32 × 32 image
is first cropped to a 24 × 24 one by taking the center patch.
The network architecture consists of two convolutional lay-
ers followed by two fully connected layers. The convolutional
layers use 5 × 5 convolutions with stride 1, followed by a
ReLU and 2 × 2 max pools, with 64 channels each. Thus
the first convolution outputs a 12 × 12 × 64 tensor for each
image, and the second outputs a 6×6×64 tensor. The latter
is flattened to a vector that gets fed into a fully connected
layer with 384 units, and another one of the same size.
This architecture, non-privately, can get to about 86% ac-
curacy in 500 epochs. Its simplicity makes it an appealing
choice for our work. We should note however that by us-
ing deeper networks with different non-linearities and other
advanced techniques, one can obtain significantly better ac-
curacy, with the state-of-the-art being about 96.5% [26].
As is standard for such image datasets, we use data aug-
mentation during training. For each training image, we gen-
erate a new distorted image by randomly picking a 24 × 24
patch from the image, randomly flipping the image along
the left-right direction, and randomly distorting the bright-
ness and the contrast of the image. In each epoch, these
(1) ε = 2 (2) ε = 4 (3) ε = 8
Figure 6: Results on accuracy for different noise levels on CIFAR-10. With δ set to 10−5, we achieve accuracy
67%, 70%, and 73%, with ε being 2, 4, and 8, respectively. The first graph uses a lot size of 2,000, (2) and (3)
use a lot size of 4,000. In all cases, σ is set to 6, and clipping is set to 3.
distortions are done independently. We refer the reader to
the TensorFlow tutorial [2] for additional details.
As the convolutional layers have shared parameters, com-
puting per-example gradients has a larger computational
overhead. Previous work has shown that convolutional lay-
ers are often transferable: parameters learned from one data-
set can be used on another one without retraining [30]. We
treat the CIFAR-100 dataset as a public dataset and use it
to train a network with the same architecture. We use the
convolutions learned from training this dataset. Retrain-
ing only the fully connected layers with this architecture for
about 250 epochs with a batch size of 120 gives us approxi-
mately 80% accuracy, which is our non-private baseline.
Differentially private version.
For the differentially private version, we use the same ar-
chitecture. As discussed above, we use pre-trained convolu-
tional layers. The fully connected layers are initialized from
the pre-trained network as well. We train the softmax layer,
and either the top or both fully connected layers. Based on
looking at gradient norms, the softmax layer gradients are
roughly twice as large as the other two layers, and we keep
this ratio when we try clipping at a few different values be-
tween 3 and 10. The lot size is an additional knob that we
tune: we tried 600, 2,000, and 4,000. With these settings,
the per-epoch training time increases from approximately 40
seconds to 180 seconds.
In Figure 6, we show the evolution of the accuracy and
the privacy cost, as a function of the number of epochs, for
a few different parameter settings.
The various parameters influence the accuracy one gets, in
ways not too different from that in the MNIST experiments.
A lot size of 600 leads to poor results on this dataset and
we need to increase it to 2,000 or more for results reported
in Figure 6.
Compared to the MNIST dataset, where the difference in
accuracy between a non-private baseline and a private model
is about 1.3%, the corresponding drop in accuracy in our
CIFAR-10 experiment is much larger (about 7%). We leave
closing this gap as an interesting test for future research in
differentially private machine learning.
6. RELATED WORK
The problem of privacy-preserving data mining, or ma-
chine learning, has been a focus of active work in several
research communities since the late 90s [5, 37]. The exist-
ing literature can be broadly classified along several axes:
the class of models, the learning algorithm, and the privacy
guarantees.
Privacy guarantees. Early works on privacy-preserving
learning were done in the framework of secure function eval-
uation (SFE) and secure multi-party computations (MPC),
where the input is split between two or more parties, and
the focus is on minimizing information leaked during the
joint computation of some agreed-to functionality. In con-
trast, we assume that data is held centrally, and we are
concerned with leakage from the functionality’s output (i.e.,
the model).
Another approach, k-anonymity and closely related no-
tions [53], seeks to offer a degree of protection to underlying
data by generalizing and suppressing certain identifying at-
tributes. The approach has strong theoretical and empirical
limitations [4, 9] that make it all but inapplicable to de-
anonymization of high-dimensional, diverse input datasets.
Rather than pursue input sanitization, we keep the under-
lying raw records intact and perturb derived data instead.
The theory of differential privacy, which provides the an-
alytical framework for our work, has been applied to a large
collection of machine learning tasks that differed from ours
either in the training mechanism or in the target model.
The moments accountant is closely related to the notion of
R´enyi differential privacy [42], which proposes (scaled) α(λ)
as a means of quantifying privacy guarantees. In a concur-
rent and independent work Bun and Steinke [10] introduce
a relaxation of differential privacy (generalizing the work
of Dwork and Rothblum [20]) defined via a linear upper
bound on α(λ). Taken together, these works demonstrate
that the moments accountant is a useful technique for theo-
retical and empirical analyses of complex privacy-preserving
algorithms.
Learning algorithm. A common target for learning with
privacy is a class of convex optimization problems amenable
to a wide variety of techniques [18, 11, 34]. In concurrent
work, Wu et al. achieve 83% accuracy on MNIST via con-
vex empirical risk minimization [57]. Training multi-layer
neural networks is non-convex, and typically solved by an
application of SGD, whose theoretical guarantees are poorly
understood.
For the CIFAR neural network we incorporate differen-
tially private training of the PCA projection matrix [23],
which is used to reduce dimensionality of inputs.
Model class. The first end-to-end differentially private sys-
tem was evaluated on the Netflix Prize dataset [39], a version
of a collaborative filtering problem. Although the problem
shared many similarities with ours—high-dimensional in-
puts, non-convex objective function—the approach taken by
McSherry and Mironov differed significantly. They identified
the core of the learning task, effectively sufficient statistics,
that can be computed in a differentially private manner via
a Gaussian mechanism. In our approach no such sufficient
statistics exist.
In a recent work Shokri and Shmatikov [50] designed and
evaluated a system for distributed training of a deep neural
network. Participants, who hold their data closely, commu-
nicate sanitized updates to a central authority. The sani-
tization relies on an additive-noise mechanism, based on a
sensitivity estimate, which could be improved to a hard sen-
sitivity guarantee. They compute privacy loss per param-
eter (not for an entire model). By our preferred measure,
the total privacy loss per participant on the MNIST dataset
exceeds several thousand.
A different, recent approach towards differentially private
deep learning is explored by Phan et al. [45]. This work
focuses on learning autoencoders. Privacy is based on per-
turbing the objective functions of these autoencoders.
7. CONCLUSIONS
We demonstrate the training of deep neural networks with
differential privacy, incurring a modest total privacy loss,
computed over entire models with many parameters. In
our experiments for MNIST, we achieve 97% training accu-
racy and for CIFAR-10 we achieve 73% accuracy, both with
(8, 10−5)-differential privacy. Our algorithms are based on a
differentially private version of stochastic gradient descent;
they run on the TensorFlow software library for machine
learning. Since our approach applies directly to gradient
computations, it can be adapted to many other classical
and more recent first-order optimization methods, such as
NAG [43], Momentum [48], AdaGrad [15], or SVRG [31].
A new tool, which may be of independent interest, is a
mechanism for tracking privacy loss, the moments accoun-
tant. It permits tight automated analysis of the privacy loss
of complex composite mechanisms that are currently beyond
the reach of advanced composition theorems.
A number of avenues for further work are attractive. In
particular, we would like to consider other classes of deep
networks. Our experience with MNIST and CIFAR-10 should
be helpful, but we see many opportunities for new research,
for example in applying our techniques to LSTMs used for
language modeling tasks. In addition, we would like to ob-
tain additional improvements in accuracy. Many training
datasets are much larger than those of MNIST and CIFAR-
10; accuracy should benefit from their size.
8. ACKNOWLEDGMENTS
We are grateful to ´Ulfar Erlingsson and Dan Ramage for
many useful discussions, and to Mark Bun and Thomas
Steinke for sharing a draft of [10].
9. REFERENCES
[1] CIFAR-10 and CIFAR-100 datasets.
www.cs.toronto.edu/˜kriz/cifar.html.
[2] TensorFlow convolutional neural networks tutorial.
www.tensorflow.org/tutorials/deep cnn.
[3] TensorFlow: Large-scale machine learning on
heterogeneous systems, 2015. Software available from
tensorflow.org.
[4] C. C. Aggarwal. On k-anonymity and the curse of
dimensionality. In VLDB, pages 901–909, 2005.
[5] R. Agrawal and R. Srikant. Privacy-preserving data
mining. In SIGMOD, pages 439–450. ACM, 2000.
[6] R. Bassily, K. Nissim, A. Smith, T. Steinke,
U. Stemmer, and J. Ullman. Algorithmic stability for
adaptive data analysis. In STOC, pages 1046–1059.
ACM, 2016.
[7] R. Bassily, A. D. Smith, and A. Thakurta. Private
empirical risk minimization: Efficient algorithms and
tight error bounds. In FOCS, pages 464–473. IEEE,
2014.
[8] A. Beimel, H. Brenner, S. P. Kasiviswanathan, and
K. Nissim. Bounds on the sample complexity for
private learning and private data release. Machine
Learning, 94(3):401–437, 2014.
[9] J. Brickell and V. Shmatikov. The cost of privacy:
Destruction of data-mining utility in anonymized data
publishing. In KDD, pages 70–78. ACM, 2008.
[10] M. Bun and T. Steinke. Concentrated differential
privacy: Simplifications, extensions, and lower bounds.
In TCC-B.
[11] K. Chaudhuri, C. Monteleoni, and A. D. Sarwate.
Differentially private empirical risk minimization.
J. Machine Learning Research, 12:1069–1109, 2011.
[12] R. Collobert, K. Kavukcuoglu, and C. Farabet.
Torch7: A Matlab-like environment for machine
learning. In BigLearn, NIPS Workshop, number
EPFL-CONF-192376, 2011.
[13] D. D. Cox and N. Pinto. Beyond simple features: A
large-scale feature search approach to unconstrained
face recognition. In FG 2011, pages 8–15. IEEE, 2011.
[14] A. Daniely, R. Frostig, and Y. Singer. Toward deeper
understanding of neural networks: The power of
initialization and a dual view on expressivity. CoRR,
abs/1602.05897, 2016.
[15] J. Duchi, E. Hazan, and Y. Singer. Adaptive
subgradient methods for online learning and stochastic
optimization. J. Machine Learning Research,
12:2121–2159, July 2011.
[16] C. Dwork. A firm foundation for private data analysis.
Commun. ACM, 54(1):86–95, Jan. 2011.
[17] C. Dwork, K. Kenthapadi, F. McSherry, I. Mironov,
and M. Naor. Our data, ourselves: Privacy via
distributed noise generation. In EUROCRYPT, pages
486–503. Springer, 2006.
[18] C. Dwork and J. Lei. Differential privacy and robust
statistics. In STOC, pages 371–380. ACM, 2009.
[19] C. Dwork, F. McSherry, K. Nissim, and A. Smith.
Calibrating noise to sensitivity in private data
analysis. In TCC, pages 265–284. Springer, 2006.
[20] C. Dwork and A. Roth. The algorithmic foundations
of differential privacy. Foundations and Trends in
Theoretical Computer Science, 9(3–4):211–407, 2014.
[21] C. Dwork and G. N. Rothblum. Concentrated
differential privacy. CoRR, abs/1603.01887, 2016.
[22] C. Dwork, G. N. Rothblum, and S. Vadhan. Boosting
and differential privacy. In FOCS, pages 51–60. IEEE,
2010.
[23] C. Dwork, K. Talwar, A. Thakurta, and L. Zhang.
Analyze Gauss: Optimal bounds for
privacy-preserving principal component analysis. In
STOC, pages 11–20. ACM, 2014.
[24] M. Fredrikson, S. Jha, and T. Ristenpart. Model
inversion attacks that exploit confidence information
and basic countermeasures. In CCS, pages 1322–1333.
ACM, 2015.
[25] I. Goodfellow. Efficient per-example gradient
computations. CoRR, abs/1510.01799v2, 2015.
[26] B. Graham. Fractional max-pooling. CoRR,
abs/1412.6071, 2014.
[27] A. Gupta, K. Ligett, F. McSherry, A. Roth, and
K. Talwar. Differentially private combinatorial
optimization. In SODA, pages 1106–1125, 2010.
[28] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep
into rectifiers: Surpassing human-level performance on
ImageNet classification. In ICCV, pages 1026–1034.
IEEE, 2015.
[29] R. Ierusalimschy, L. H. de Figueiredo, and W. Filho.
Lua—an extensible extension language. Software:
Practice and Experience, 26(6):635–652, 1996.
[30] K. Jarrett, K. Kavukcuoglu, M. Ranzato, and
Y. LeCun. What is the best multi-stage architecture
for object recognition? In ICCV, pages 2146–2153.
IEEE, 2009.
[31] R. Johnson and T. Zhang. Accelerating stochastic
gradient descent using predictive variance reduction.
In NIPS, pages 315–323, 2013.
[32] P. Kairouz, S. Oh, and P. Viswanath. The composition
theorem for differential privacy. In ICML, pages
1376–1385. ACM, 2015.
[33] S. P. Kasiviswanathan, H. K. Lee, K. Nissim,
S. Raskhodnikova, and A. Smith. What can we learn
privately? SIAM J. Comput., 40(3):793–826, 2011.
[34] D. Kifer, A. D. Smith, and A. Thakurta. Private
convex optimization for empirical risk minimization
with applications to high-dimensional regression. In
COLT, pages 25.1–25.40, 2012.
[35] A. Krizhevsky, I. Sutskever, and G. E. Hinton.
ImageNet classification with deep convolutional neural
networks. In NIPS, pages 1097–1105, 2012.
[36] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner.
Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11), 1998.
[37] Y. Lindell and B. Pinkas. Privacy preserving data
mining. In CRYPTO, pages 36–54. Springer, 2000.
[38] C. J. Maddison, A. Huang, I. Sutskever, and D. Silver.
Move evaluation in Go using deep convolutional neural
networks. In ICLR, 2015.
[39] F. McSherry and I. Mironov. Differentially private
recommender systems: Building privacy into the
Netflix Prize contenders. In KDD, pages 627–636.
ACM, 2009.
[40] F. D. McSherry. Privacy integrated queries: An
extensible platform for privacy-preserving data
analysis. In SIGMOD, pages 19–30. ACM, 2009.
[41] T. Mikolov, K. Chen, G. Corrado, and J. Dean.
Efficient estimation of word representations in vector
space. CoRR, abs/1301.3781, 2013.
[42] I. Mironov. R´enyi differential privacy. Private
communication, 2016.
[43] Y. Nesterov. Introductory Lectures on Convex
Optimization. A Basic Course. Springer, 2004.
[44] J. Pennington, R. Socher, and C. D. Manning. GloVe:
Global vectors for word representation. In EMNLP,
pages 1532–1543, 2014.
[45] N. Phan, Y. Wang, X. Wu, and D. Dou. Differential
privacy preservation for deep auto-encoders: an
application of human behavior prediction. In AAAI,
pages 1309–1316, 2016.
[46] N. Pinto, Z. Stone, T. E. Zickler, and D. Cox. Scaling
up biologically-inspired computer vision: A case study
in unconstrained face recognition on Facebook. In
CVPR, pages 35–42. IEEE, 2011.
[47] R. M. Rogers, A. Roth, J. Ullman, and S. P. Vadhan.
Privacy odometers and filters: Pay-as-you-go
composition. In NIPS.
[48] D. E. Rumelhart, G. E. Hinton, and R. J. Williams.
Learning representations by back-propagating errors.
Nature, 323:533–536, Oct. 1986.
[49] A. Saxe, P. W. Koh, Z. Chen, M. Bhand, B. Suresh,
and A. Ng. On random weights and unsupervised
feature learning. In ICML, pages 1089–1096. ACM,
2011.
[50] R. Shokri and V. Shmatikov. Privacy-preserving deep
learning. In CCS, pages 1310–1321. ACM, 2015.
[51] D. Silver, A. Huang, C. J. Maddison, A. Guez,
L. Sifre, G. van den Driessche, J. Schrittwieser,
I. Antonoglou, V. Panneershelvam, M. Lanctot,
S. Dieleman, D. Grewe, J. Nham, N. Kalchbrenner,
I. Sutskever, T. Lillicrap, M. Leach, K. Kavukcuoglu,
T. Graepel, and D. Hassabis. Mastering the game of
Go with deep neural networks and tree search. Nature,
529(7587):484–489, 2016.
[52] S. Song, K. Chaudhuri, and A. Sarwate. Stochastic
gradient descent with differentially private updates. In
GlobalSIP Conference, 2013.
[53] L. Sweeney. k-anonymity: A model for protecting
privacy. International J. of Uncertainty, Fuzziness and
Knowledge-Based Systems, 10(05):557–570, 2002.
[54] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and
A. Rabinovich. Going deeper with convolutions. In
CVPR, pages 1–9. IEEE, 2015.
[55] S. Tu, R. Roelofs, S. Venkataraman, and B. Recht.
Large scale kernel learning using block coordinate
descent. CoRR, abs/1602.05310, 2016.
[56] O. Vinyals, L. Kaiser, T. Koo, S. Petrov, I. Sutskever,
and G. E. Hinton. Grammar as a foreign language. In
NIPS, pages 2773–2781, 2015.
[57] X. Wu, A. Kumar, K. Chaudhuri, S. Jha, and J. F.
Naughton. Differentially private stochastic gradient
descent for in-RDBMS analytics. CoRR,
abs/1606.04722, 2016.
APPENDIX
A. PROOF OF THEOREM 2
Here we restate and prove Theorem 2.
Theorem 2. Let αM(λ) defined as
αM(λ) ∆
= max
aux,d,d′ αM(λ; aux, d, d′),
where the maximum is taken over all auxiliary inputs and
neighboring databases d, d′. Then
1. [Composability] Suppose that a mechanism M con-
sists of a sequence of adaptive mechanisms M1, . . . , Mk
where Mi : ∏i−1
j=1 Rj × D → Ri. Then, for any λ
αM(λ) ≤
k∑
i=1
αMi (λ) .
2. [Tail bound] For any ε > 0, the mechanism M is
(ε, δ)-differentially private for
δ = min
λ exp(αM(λ) − λε) .
Proof. Composition of moments. For brevity, let
M1:i denote (M1, . . . , Mi), and similarly let o1:i denote
(o1, . . . , oi). For neighboring databases d, d′ ∈ Dn, and a
sequence of outcomes o1, . . . , ok we write
c(o1:k ; M1:k , o1:(k−1), d, d′)
= log Pr[M1:k (d; o1:(k−1)) = o1:k ]
Pr[M1:k (d′; o1:(k−1)) = o1:k ]
= log
k∏
i=1
Pr[Mi(d) = oi | M1:(i−1)(d) = o1:(i−1)]
Pr[Mi(d′) = oi | M1:(i−1)(d′) = o1:(i−1)]
=
k∑
i=1
log Pr[Mi(d) = oi | M1:(i−1)(d) = o1:(i−1)]
Pr[Mi(d′) = oi | M1:(i−1)(d′) = o1:(i−1)]
=
k∑
i=1
c(oi; Mi, o1:(i−1), d, d′).
Thus
Eo′
1:k ∼M1:k (d)
[ exp(λc(o′
1:k ; M1:k , d, d′)) ∣
∣ ∀i < k : o′
i = oi
]
= Eo′
1:k ∼M1:k (d)
[
exp
(
λ
k∑
i=1
c(o′
i; Mi, o1:(i−1), d, d′)
)]
= Eo′
1:k ∼M1:k (d)
[ k∏
i=1
exp (λc(o′
i; Mi, o1:(i−1), d, d′))]
(by independence of noise)
=
k∏
i=1
Eo′
i∼Mi(d)
[exp(λc(o′
i; Mi, o1:(i−1), d, d′))]
=
k∏
i=1
exp (αMi (λ; o1:(i−1), d, d′))
= exp
( k∑
i=1
αi(λ; o1:(i−1), d, d′)
)
.
The claim follows.
Tail bound by moments. The proof is based on the stan-
dard Markov’s inequality argument used in proofs of mea-
sure concentration. We have
Pr
o∼M(d)
[c(o) ≥ ε]
= Pr
o∼M(d)
[exp(λc(o)) ≥ exp(λε))]
≤ Eo∼M(d)[exp(λc(o))]
exp(λε)
≤ exp(α − λε).
Let B = {o : c(o) ≥ ε}. Then for any S,
Pr[M (d) ∈ S]
= Pr[M (d) ∈ S ∩ Bc] + Pr[M (d) ∈ S ∩ B]
≤ exp(ε) Pr[M (d′) ∈ S ∩ Bc] + Pr[M (d) ∈ B]
≤ exp(ε) Pr[M (d′) ∈ S] + exp(α − λε).
The second part follows by an easy calculation.
The proof demonstrates a tail bound on the privacy loss,
making it stronger than differential privacy for a fixed value
of ε, δ.
B. PROOF OF LEMMA 3
The proof of the main theorem relies on the following mo-
ments bound on Gaussian mechanism with random sam-
pling.
Lemma 3. Suppose that f : D → Rp with ‖f (·)‖2 ≤ 1.
Let σ ≥ 1 and let J be a sample from [n] where each i ∈ [n]
is chosen independently with probability q < 1
16σ . Then for
any positive integer λ ≤ σ2 ln 1
qσ , the mechanism M(d) =
∑
i∈J f (di) + N (0, σ2I) satisfies
αM(λ) ≤ q2λ(λ + 1)
(1 − q)σ2 + O(q3λ3/σ3).
Proof. Fix d′ and let d = d′ ∪ {dn}. Without loss of
generality, f (dn) = e1 and ∑
i∈J\[n] f (di) = 0. Thus M(d)
and M(d′) are distributed identically except for the first
coordinate and hence we have a one-dimensional problem.
Let μ0 denote the pdf of N (0, σ2) and let μ1 denote the pdf
of N (1, σ2). Thus:
M(d′) ∼ μ0,
M(d) ∼ μ ∆
= (1 − q)μ0 + qμ1.
We want to show that
Ez∼μ[(μ(z)/μ0(z))λ] ≤ α,
and Ez∼μ0 [(μ0(z)/μ(z))λ] ≤ α,
for some explicit α to be determined later.
We will use the same method to prove both bounds. As-
sume we have two distributions ν0 and ν1, and we wish to
bound
Ez∼ν0 [(ν0(z)/ν1(z))λ] = Ez∼ν1 [(ν0(z)/ν1(z))λ+1] .
Using binomial expansion, we have
Ez∼ν1 [(ν0(z)/ν1(z))λ+1]
= Ez∼ν1 [(1 + (ν0(z) − ν1(z))/ν1(z))λ+1]
= Ez∼ν1 [(1 + (ν0(z) − ν1(z))/ν1(z))λ+1]
=
λ+1∑
t=0
(
λ + 1
t
)
Ez∼ν1 [((ν0(z) − ν1(z))/ν1(z))t] . (5)
The first term in (5) is 1, and the second term is
Ez∼ν1
[ ν0(z) − ν1(z)
ν1(z)
]
=
∫ ∞
−∞
ν1(z) ν0(z) − ν1(z)
ν1(z) dz
=
∫ ∞
−∞
ν0(z) dz −
∫ ∞
−∞
ν1(z) dz
= 1 − 1 = 0.
To prove the lemma it suffices to show show that for both
ν0 = μ, ν1 = μ0 and ν0 = μ0, ν1 = μ, the third term is
bounded by q2λ(λ + 1)/(1 − q)σ2 and that this bound dom-
inates the sum of the remaining terms. We will prove the
more difficult second case (ν0 = μ0, ν1 = μ); the proof of the
other case is similar.
To upper bound the third term in (5), we note that μ(z) ≥
(1 − q)μ0(z), and write
Ez∼μ
[( μ0(z) − μ(z)
μ(z)
)2]
= q2Ez∼μ
[( μ0(z) − μ1(z)
μ(z)
)2]
= q2
∫ ∞
−∞
(μ0(z) − μ1(z))2
μ(z) dz
≤ q2
1 − q
∫ ∞
−∞
(μ0(z) − μ1(z))2
μ0(z) dz
= q2
1 − q Ez∼μ0
[( μ0(z) − μ1(z)
μ0(z)
)2]
.
An easy fact is that for any a ∈ R, Ez∼μ0 exp(2az/2σ2) =
exp(a2/2σ2). Thus,
Ez∼μ0
[( μ0(z) − μ1(z)
μ0(z)
)2]
= Ez∼μ0
[(
1 − exp( 2z − 1
2σ2 )
)2]
= 1 − 2Ez∼μ0
[
exp( 2z − 1
2σ2 )
]
+ Ez∼μ0
[
exp( 4z − 2
2σ2 )
]
= 1 − 2 exp
( 1
2σ2
)
· exp
( −1
2σ2
)
+ exp
( 4
2σ2
)
· exp
( −2
2σ2
)
= exp(1/σ2) − 1.
Thus the third term in the binomial expansion (5)
(
1 + λ
2
)
Ez∈μ
[( μ0(z) − μ(z)
μ(z)
)2]
≤ λ(λ + 1)q2
(1 − q)σ2 .
To bound the remaining terms, we first note that by stan-
dard calculus, we get:
∀z ≤ 0 : |μ0(z) − μ1(z)| ≤ −(z − 1)μ0(z)/σ2,
∀z ≥ 1 : |μ0(z) − μ1(z)| ≤ zμ1(z)/σ2,
∀0 ≤ z ≤ 1 : |μ0(z) − μ1(z)| ≤ μ0(z)(exp(1/2σ2) − 1)
≤ μ0(z)/σ2.
We can then write
Ez∼μ
[( μ0(z) − μ(z)
μ(z)
)t]
≤
∫ 0
−∞
μ(z)
∣
∣
∣
∣
∣
( μ0(z) − μ(z)
μ(z)
)t∣
∣
∣
∣
∣ dz
+
∫ 1
0
μ(z)
∣
∣
∣
∣
∣
( μ0(z) − μ(z)
μ(z)
)t∣
∣
∣
∣
∣ dz
+
∫ ∞
1
μ(z)
∣
∣
∣
∣
∣
( μ0(z) − μ(z)
μ(z)
)t∣
∣
∣
∣
∣ dz.
We consider these terms individually. We repeatedly make
use of three observations: (1) μ0 − μ = q(μ0 − μ1), (2)
μ ≥ (1 − q)μ0, and (3) Eμ0 [|z|t] ≤ σt(t − 1)!!. The first term
can then be bounded by
qt
(1 − q)t−1σ2t
∫ 0
−∞
μ0(z)|z − 1|t dz
≤ (2q)t(t − 1)!!
2(1 − q)t−1σt .
The second term is at most
qt
(1 − q)t
∫ 1
0
μ(z)
∣
∣
∣
∣
∣
( μ0(z) − μ1(z)
μ0(z)
)t∣
∣
∣
∣
∣ dz
≤ qt
(1 − q)t
∫ 1
0
μ(z) 1
σ2t dz
≤ qt
(1 − q)tσ2t .
Similarly, the third term is at most
qt
(1 − q)t−1σ2t
∫ ∞
1
μ0(z)
( zμ1(z)
μ0(z)
)t
dz
≤ qt
(1 − q)t−1σ2t
∫ ∞
1
μ0(z) exp((2tz − t)/2σ2)zt dz
≤ qt exp((t2 − t)/2σ2)
(1 − q)t−1σ2t
∫ ∞
0
μ0(z − t)zt dz
≤ (2q)t exp((t2 − t)/2σ2)(σt(t − 1)!! + tt)
2(1 − q)t−1σ2t .
Under the assumptions on q, σ, and λ, it is easy to check
that the three terms, and their sum, drop off geometrically
fast in t for t > 3. Hence the binomial expansion (5) is
dominated by the t = 3 term, which is O(q3λ3/σ3). The
claim follows.
To derive Theorem 1, we use the above moments bound
along with the tail bound from Theorem 2, optimizing over
the choice of λ.
Theorem 1. There exist constants c1 and c2 so that given
the sampling probability q = L/N and the number of steps
T , for any ε < c1q2T , Algorithm 1 is (ε, δ)-differentially
private for any δ > 0 if we choose
σ ≥ c2
q√T log(1/δ)
ε .
Proof. Assume for now that σ, λ satisfy the conditions
in Lemma 3. By Theorem 2.1 and Lemma 3, the log mo-
ment of Algorithm 1 can be bounded as follows α(λ) ≤
T q2λ2/σ2. By Theorem 2, to guarantee Algorithm 1 to be
(ε, δ)-differentially private, it suffices that
T q2λ2/σ2 ≤ λε/2 ,
exp(−λε/2) ≤ δ .
In addition, we need
λ ≤ σ2 log(1/qσ) .
It is now easy to verify that when ε = c1q2T , we can satisfy
all these conditions by setting
σ = c2
q√T log(1/δ)
ε
for some explicit constants c1 and c2.
C. FROM DIFFERENTIAL PRIVACY TO MO-
MENTS BOUNDS
One can also translate a differential privacy guarantee into
a moment bound.
Lemma C.1. Let M be ε-differentially private. Then for
any λ > 0, M satisfies
αλ ≤ λε(eε − 1) + λ2ε2e2ε/2.
Proof. Let Z denote the random variable c(M(d)). Then
differential privacy implies that
• μ ∆
= E[Z] ≤ ε(exp(ε) − 1).
• |Z| ≤ ε, so that |Z − μ| ≤ ε exp(ε).
Then E[exp(λZ)] = exp(λμ) · E[exp(λ(Z − μ))]. Since Z is in
a bounded range [−ε exp(ε), ε exp(ε)] and f (x) = exp(λx) is
convex, we can bound f (x) by a linear interpolation between
the values at the two endpoints of the range. Basic calculus
then implies that
E[f (Z)] ≤ f (E[Z]) · exp(λ2ε2 exp(2ε)/2),
which concludes the proof.
Lemma C.1 and Theorem 2 give a way of getting a compo-
sition theorem for differentially private mechanisms, which
is roughly equivalent to unrolling the proof of the strong
composition theorem of [22]. The power of the moments ac-
countant comes from the fact that, for many mechanisms of
choice, directly bounding in the moments gives a stronger
guarantee than one would get by establishing differential
privacy and applying Lemma C.1.
D. HYPERPARAMETER SEARCH
Here we state Theorem 10.2 from [27] that we use to ac-
count for the cost of hyperparameter search.
Theorem D.1 (Gupta et al. [27]). Let M be an ε -
differentially private mechanism such that for a query func-
tion q with sensitivity 1, and a parameter Q, it holds that
Prr∼M (d)[q(d, r) ≥ Q] ≥ p for some p ∈ (0, 1). Then for any
δ > 0 and any ε′ ∈ (0, 1
2 ), there is a mechanism M ′ which
satisfies the following properties:
• Prr∼M ′(d)
[
q(d, r) ≥ Q − 4
ε′ log( 1
ε′δp )
]
≥ 1 − δ.
• M ′ makes ( 1
ε′δp )2 log( 1
ε′δp ) calls to M .
• M ′ is (ε + 8ε′)-differentially private.
Suppose that we have a differentially private mechanism
Mi for each of K choices of hyperparameters. Let ˜M be the
mechanism that picks a random choice of hyperparameters,
and runs the corresponding Mi. Let q(d, r) denote the num-
ber of examples from the validation set the r labels correctly,
and let Q be a target accuracy. Assuming that one of the
hyperparameter settings gets accuracy at least Q, ˜M satis-
fies the pre-conditions of the theorem for p = 1
K . Then with
high probability, the mechanism implied by the theorem gets
accuracy close to Q. We remark that the proof of Theo-
rem D.1 actually implies a stronger max(ε, 8ε′)-differential
privacy for the setting of interest here.
Putting in some numbers, for a target accuracy of 95% on
a validation set of size 10,000, we get Q = 9, 500. Thus, if,
for instance, we allow ε′ = 0.5, and δ = 0.05, we lose at most
1% in accuracy as long as 100 > 8 ln 40
p . This is satisfied as
long as p ≥ 1
6700 . In other words, one can try 6,700 different
parameter settings at privacy cost ε = 4 for the validation
set. In our experiments, we tried no more than a hundred
settings, so that this bound is easily satisfied. In practice,
as our graphs show, p for our hyperparameter search is sig-
nificantly larger than 1
K , so that a slightly smaller ε′ should
suffice.
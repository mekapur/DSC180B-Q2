<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Takeaways | Training-based vs Training-free Differential Privacy</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body data-page="takeaways">
  <div id="siteHeader"></div>

  <main>
    <section class="section">
      <h1>Discussion and Takeaways</h1>
      <p class="lead">
        What we learned from comparing training-based and training-free approaches for differentially private synthetic data.
      </p>
    </section>

    <!-- DISCUSSION -->
    <section class="section">
      <h2>Key Takeaways</h2>

      <h3>1. Per-Table Independence Breaks Cross-Table Queries</h3>
      <p>
        Per-table DP-SGD and MST both generated high-fidelity data within individual tables but failed on queries
        that joined multiple tables. Foreign-key mismatches and missing group overlaps (low Jaccard similarity) meant
        that aggregate queries across tables saw inflated relative errors.
      </p>
      <p><strong>Lesson:</strong> Protecting per-table privacy is not sufficient for relational workloads.</p>

      <h3>2. Wide-Table Sparsity Collapses Continuous Metrics</h3>
      <p>
        When we flattened all tables into one wide table, the extreme sparsity (mostly null values) caused the VAE
        to encode numeric columns as near-zero distributions. This destroyed the utility of metrics like power consumption,
        network throughput, and RAM usage.
      </p>
      <p><strong>Lesson:</strong> Wide-table representations are impractical for sparse, multi-table data without structural preprocessing.</p>

      <h3>3. DP Noise is Necessary But Limiting</h3>
      <p>
        All methods added noise for privacy. While this successfully protected individuals, it also masked subtle
        relationships (e.g., correlation between CPU frequency and power consumption) and rare subgroups. Even with
        epsilon = 1.0 (moderate privacy), accuracy on niche queries suffered.
      </p>
      <p><strong>Lesson:</strong> Privacy and utility are fundamentally at odds; query-specific privacy budgets (composition) may help.</p>

      <h3>4. Training-Free Methods Have Knowledge Ceiling</h3>
      <p>
        Private Evolution relied on an LLM's knowledge. When real data contained categories or values unseen by the LLM
        (e.g., geographic regions, rare OS versions, niche applications), the method could not synthesize them, leading
        to 0% group coverage on those queries.
      </p>
      <p><strong>Lesson:</strong> Training-free methods are faster but fundamentally limited by their knowledge source.</p>

      <h3>5. Simple Distributions are Tractable</h3>
      <p>
        Queries on categorical or binned distributions with few categories (e.g., browser usage, vendor percentages)
        passed across multiple methods. These results suggest that distribution synthesis, when data is not too sparse,
        is a solved problem.
      </p>
      <p><strong>Lesson:</strong> Focus optimization efforts on hard problems (joins, rare subgroups, continuous metrics).</p>
    </section>

    <!-- INSIGHTS INTO APPROACHES -->
    <section class="section">
      <h2>Comparative Insights</h2>

      <h3>Per-Table DP-SGD vs. Wide-Table DP-VAE</h3>
      <table style="width: 100%; border-collapse: collapse; margin-top: 16px;">
        <tr style="border-bottom: 1px solid var(--border);">
          <th style="text-align: left; padding: 8px;">Aspect</th>
          <th style="text-align: left; padding: 8px;">Per-Table</th>
          <th style="text-align: left; padding: 8px;">Wide-Table</th>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Within-table quality</td>
          <td style="padding: 8px;">High</td>
          <td style="padding: 8px;">Low (sparsity collapse)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Cross-table fidelity</td>
          <td style="padding: 8px;">Poor (independence)</td>
          <td style="padding: 8px;">Medium (structural)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Training time</td>
          <td style="padding: 8px;">Fast (per table)</td>
          <td style="padding: 8px;">Slow (large model)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Privacy cost</td>
          <td style="padding: 8px;">Low (epsilon per table)</td>
          <td style="padding: 8px;">High (single model)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Mode collapse risk</td>
          <td style="padding: 8px;">Medium</td>
          <td style="padding: 8px;">High</td>
        </tr>
      </table>

      <h3>MST vs. Private Evolution</h3>
      <table style="width: 100%; border-collapse: collapse; margin-top: 16px;">
        <tr style="border-bottom: 1px solid var(--border);">
          <th style="text-align: left; padding: 8px;">Aspect</th>
          <th style="text-align: left; padding: 8px;">MST</th>
          <th style="text-align: left; padding: 8px;">Private Evolution</th>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Speed</td>
          <td style="padding: 8px;">Medium (marginal estimation)</td>
          <td style="padding: 8px;">Fast (if LLM cached)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Interpretability</td>
          <td style="padding: 8px;">High (marginals transparent)</td>
          <td style="padding: 8px;">Low (LLM black-box)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Category coverage</td>
          <td style="padding: 8px;">All real categories</td>
          <td style="padding: 8px;">Limited to LLM knowledge</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Workload awareness</td>
          <td style="padding: 8px;">No</td>
          <td style="padding: 8px;">Yes (can target queries)</td>
        </tr>
        <tr style="border-bottom: 1px solid var(--border);">
          <td style="padding: 8px;">Wide-table capability</td>
          <td style="padding: 8px;">Exponential in width</td>
          <td style="padding: 8px;">Agnostic to schema</td>
        </tr>
      </table>
    </section>

    <!-- RECOMMENDATIONS FOR PRACTITIONERS -->
    <section class="section">
      <h2>Recommendations for Practice</h2>

      <h3>When to Use Each Method</h3>
      <ul class="bullets">
        <li>
          <strong>MST (Marginal Synthesis):</strong> Best for low-cardinality tables with clear relationships.
          Good for one-time bulk synthetic generation. Requires no training.
        </li>
        <li>
          <strong>Per-Table DP-SGD:</strong> When you need high within-table fidelity and can afford modest
          cross-table inaccuracy. Good for row-level analytics. Requires careful hyperparameter tuning.
        </li>
        <li>
          <strong>Wide-Table DP-VAE:</strong> Avoid on sparse, multi-table data. Consider only if tables are
          naturally wide (many columns) and densely populated.
        </li>
        <li>
          <strong>Private Evolution:</strong> Useful when you have strong workload priors and want targeted synthesis.
          Requires curating or fine-tuning the LLM's knowledge.
        </li>
      </ul>

      <h3>Hybrid Strategy</h3>
      <p>
        No single method dominates. Consider a hybrid approach:
      </p>
      <ul class="bullets">
        <li>Route <strong>simple queries</strong> (single-table aggregates) to MST.</li>
        <li>Route <strong>distribution queries</strong> (histograms, percentages) to per-table DP-SGD or MST, whichever passes validation.</li>
        <li>Route <strong>ranking queries</strong> to MST (good Jaccard overlap).</li>
        <li>Route <strong>cross-table joins</strong> to relational DP methods or consider query-specific noising strategies.</li>
      </ul>

      <h3>Privacy Configuration</h3>
      <ul class="bullets">
        <li>Start with epsilon = 1.0 (moderate privacy). Lower epsilon for stronger privacy; expect accuracy to degrade.</li>
        <li>Use advanced composition (e.g., Renyi differential privacy) to allocate privacy budgets across multiple queries.</li>
        <li>Consider local DP for sensitive attributes; use global DP for aggregate queries.</li>
      </ul>

      <h3>Data Preprocessing</h3>
      <ul class="bullets">
        <li>Normalize continuous columns to [0, 1] before training. This reduces sparsity artifacts.</li>
        <li>Represent multi-table data as a graph or relational schema explicitly, not as a wide table.</li>
        <li>Create domain-specific attributes (e.g., "power efficiency" = power / CPU frequency) to guide synthesis.</li>
      </ul>
    </section>

    <!-- FUTURE DIRECTIONS -->
    <section class="section">
      <h2>Future Directions</h2>

      <h3>Relational Differential Privacy</h3>
      <p>
        Next step: develop methods that reason about foreign-key relationships directly, applying DP at the join level
        rather than per-table or wide-table. This could unlock better performance on complex queries.
      </p>

      <h3>Workload-Specific DP</h3>
      <p>
        Allocate privacy budgets per query type. Use local DP for sensitive attributes and global DP for utility-driven aggregates.
      </p>

      <h3>Improved LLM Knowledge Bases</h3>
      <p>
        For training-free approaches, augment LLMs with domain-specific knowledge (real category lists, schema constraints)
        to improve category coverage and reduce 0% group coverage failures.
      </p>

      <h3>Quantization and Discretization</h3>
      <p>
        Better handling of continuous distributions via intelligent binning or quantization, reducing DP noise needed
        to protect individual values.
      </p>
    </section>

    <!-- CONCLUSION -->
    <section class="section" style="background: var(--card); padding: 24px; border-radius: 12px; margin-top: 24px;">
      <h2>Conclusion</h2>
      <p>
        Training-based and training-free differential privacy approaches each have strengths and weaknesses.
        <strong>There is no silver bullet.</strong> The choice depends on your workload, privacy requirements, and available resources.
      </p>
      <p>
        Our evaluation shows that:
      </p>
      <ul class="bullets">
        <li>Simple distributions are tractable; complex joins are not (yet).</li>
        <li>Per-table and wide-table synthesis represent opposite trade-offs.</li>
        <li>Hybrid, query-aware routing significantly improves overall performance.</li>
        <li>Future work in relational DP and workload-aware composition is critical.</li>
      </ul>
      <p>
        We hope this study helps practitioners make informed choices when synthesizing sensitive data under privacy constraints.
      </p>
    </section>

    <!-- LINKS TO RESOURCES -->
    <section class="section">
      <h2>Resources</h2>
      <ul class="bullets">
        <li><a href="https://github.com/mekapur/DSC180B-Q2" target="_blank" rel="noopener">GitHub Repository</a> with code and additional details.</li>
        <li><a href="https://github.com/mekapur/DSC180B-Q2/raw/main/report/q2-report.pdf" target="_blank" rel="noopener">Full Technical Report (PDF)</a> with proofs and extended results.</li>
        <li><a href="methods.html">Methods Page</a> for detailed descriptions of each approach.</li>
        <li><a href="results.html">Results Page</a> for query-by-query breakdown and failure analysis.</li>
        <li><a href="explore.html">Explore Page</a> for interactive visualizations and comparisons.</li>
      </ul>
    </section>
  </main>

  <div id="siteFooter"></div>

  <script src="app.js"></script>
</body>
</html>
